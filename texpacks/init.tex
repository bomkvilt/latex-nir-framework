%%% bootsrap.tex
% this file must be executed in the beginning of a tex document
% since it introduces the basic functions:
%   - relative includes
%   - package include guards
%%%

% LaTeX3 support >> on
% \note: must be marked as used (@usepackage)
\usepackage{expl3 }
\usepackage{xparse}
\usepackage{xargs }

\ExplSyntaxOn
\makeatletter


% -----------------| include guard

% ensure that the file wasn't includded twice
\cs_if_free:NTF \pack@g@lockGuard {
    \bool_new:N       \pack@g@lockGuard
    \bool_gset_true:N \pack@g@lockGuard
} {
    \typeout{Error:~the~file~cannot~be~included~twice}
    \stop
}


\typeout{*********************************************************************}
\typeout{**~-~-~-~-~-~-~-~-~-~Framework~was~activated~-~-~-~-~-~-~-~-~-~-~-~**}
\typeout{*********************************************************************}


% -----------------| include and input


% backup old command versions
\let\pack@old@include \include
\let\pack@old@input   \input


%%% replaces a default \include and extends it's functionality
%   #1 - document-relative file path
\RenewDocumentCommand{\include}{ m } 
{
    \pack@doInsert:Nx \pack@old@include {#1}
}


%%% replaces a default \input and extends it's functionality
%   #1 - file or document-root relative file path
\RenewDocumentCommand{\input}{ m } 
{
    \pack@doInsert:Nn \pack@old@input {#1}
}


% backup new commands versions
\let\pack@new@include \include
\let\pack@new@input   \input


%%% get a current file's document-relative path
\def\curfile { \str_use:N \pack@g@fullPath_str }


%%% get a current file's document-relative directory
\def\curdir { \str_use:N \pack@g@fullRoot_str }


%%% register an event must be colled before a matched file inclusion
%   #1  - regular expression
%   #2  - callback void()
\NewDocumentCommand{\addPreLoadEvent}{ m m }
{
    \pack@input@addEvent:Nnn \pack@g@callbacks@preLoad_seq {#1}{#2}
}


%%% register an event must be colled after a matched file inclusion
%   #1  - regular expression
%   #2  - callback void()
\NewDocumentCommand{\addPostLoadEvent}{ m m }
{
    \pack@input@addEvent:Nnn \pack@g@callbacks@postLoad_seq {#1}{#2}
}


%%% non't include the file
%   \note: calls from a @preLoad events
%   \note: affects an inclusion only. All asigned events will be called
\NewDocumentCommand{\dontIncludeSelf}{} 
{
    \bool_gset_true:N \pack@g@bNoInclude
}


% -----------------| usepackage

% \note: must be marked as used (@usepackage)
\usepackage{etoolbox}


% backup an old versuin
\let\pack@old@usepackage \usepackage


\int_new:N         \pack@g@usepackDepth_int % used to enable a new input/include commands on a document level only
\seq_new:N         \pack@g@usedPackages_seq % list of already used packages
\seq_gput_right:Nn \pack@g@usedPackages_seq {expl3 }
\seq_gput_right:Nn \pack@g@usedPackages_seq {xparse}
\seq_gput_right:Nn \pack@g@usedPackages_seq {xargs }
\seq_gput_right:Nn \pack@g@usedPackages_seq {etoolbox}


%%% prevent the command to use a package twice
%   #1  - start argument. Not in use
%   #2  - package arguments
%   #3  - package name      
% \note: comma-divied package lists are not supported yet
\RenewDocumentCommand{\usepackage}{ s o m o} {
    \ifinlist {#3} {\pack@g@usedPackages_seq} {
        % empty. The package is already in use
    } {
        % mark as included
        \seq_gpush:Nn \pack@g@usedPackages_seq {#3}

        % set basic include commands
        \pack@msg@usepackage:nn {>>}{#3}
        \int_gincr:N \pack@g@usepackDepth_int
        \let\include \pack@old@include
        \let\input   \pack@old@input
        

        % use the package        
        \IfNoValueTF {#3} 
        { \IfNoValueTF {#2} { \pack@old@usepackage{#3}     } { \pack@old@usepackage[#2]{#3}     }} 
        { \IfNoValueTF {#2} { \pack@old@usepackage{#3}[#4] } { \pack@old@usepackage[#2]{#3}[#4] }}
        

        % recover include commands
        \int_gdecr:N \pack@g@usepackDepth_int
        \int_compare:nNnTF {\pack@g@usepackDepth_int} > {0} 
        {
            \let\include \pack@old@include
            \let\input   \pack@old@input
        } 
        {
            \let\include \pack@new@include
            \let\input   \pack@new@input
        }
    }
}

% -----------------| messages.begin
% >>


\msg_new:nnn {packages} {usepackage_call} {
    Info: ~ usepackage[#1][\int_use:N \pack@g@usepackDepth_int]: ~ #2
}

\msg_new:nnn {packages} {include_call} {
    Info: ~ include[#1]: ~ #2
}

\msg_new:nnn {packages} {event_call} {
    Info: ~ event[#1]: ~ #2 ~ -> ~ #3
}

\msg_new:nnn {packages} {event_new} {
    Info: ~ event[#1]: ~ #2 -> #3
}

%%% print an information message
%   #1  - specifier
%   #2  - package name
%   #3  - mode name
\cs_new_protected:Npn \pack@msg@usepackage:nn #1 #2 {
    \msg_term:nnxx {packages} {usepackage_call} {#1} {#2}
}

%%% print an information message
%   #1  - specifier 
%   #2  - include path
\cs_new_protected:Npn \pack@msg@include:nn #1 #2 {
    \msg_term:nnxx {packages} {include_call} {#1} {#2}
}

%%% print an information message
%   #1  - regex
%   #2  - passed path
%   #3  - callback
\cs_new_protected:Npn \pack@msg@eventCall:nnn #1 #2 #3 {
    \msg_term:nnnnn {packages} {event_call} {#1} {#2} {#3}
}
\cs_generate_variant:Nn \pack@msg@eventCall:xnx {}

%%% print an information message
%   #1  - prefix
%   #2  - rule
%   #3  - callback
\cs_new_protected:Npn \pack@msg@eventNew:nnn #1 #2 #3 {
    \msg_term:nnnnn {packages} {event_call} {#1} {#2} {#3}
}

% >>
% -----------------| messages.end
% -----------------| input.realisation.begin
% >>


% current values
\str_new:N  \pack@g@fullRoot_str % current file's directory's document-relative path
\str_new:N  \pack@g@fullPath_str % current file's document-relative path
\bool_new:N \pack@g@bRelPath     % was the file includded as a relative or not
\bool_set_true:N \pack@g@brelPath % the root document can be interpreted in two ways

% stacks of current variables
\seq_new:N \pack@g@rootStack_seq
\seq_new:N \pack@g@fileStack_seq
\seq_new:N \pack@g@bRelStack_seq
\seq_gput_right:NV \pack@g@rootStack_seq \pack@g@fullRoot_str
\seq_gput_right:NV \pack@g@fileStack_seq \pack@g@fullPath_str
\seq_gput_right:NV \pack@g@bRelStack_seq \pack@g@bRelPath

% lists of callbacks and evluation
\bool_new:N \pack@g@bNoInclude % prevent the file's inclusion
\seq_new:N \pack@g@callbacks@preLoad_seq
\seq_new:N \pack@g@callbacks@postLoad_seq


%%% use a specified command to insert a spicified file 
%   #1  - include|input command wrapper
%   #2  - file/document relative path
\cs_new_protected:Npn \pack@doInsert:Nn #1 #2 {
    % deduce new stacks' top values
    \pack@input@putFrame:n {#2}

    \pack@msg@include:nn {>>}{\curfile}
    % call pre- and postload events and include the path if it's required
    \bool_gset_false:N \pack@g@bNoInclude
    \pack@input@callEvent:Nx \pack@g@callbacks@preLoad_seq \curfile
    \bool_if:nTF \pack@g@bNoInclude 
    {
        \pack@msg@include:nn {NO}{\curfile}
    }
    {
        #1{\curfile}
    }
    \pack@input@callEvent:Nx \pack@g@callbacks@postLoad_seq \curfile
    
    % pop current variables (close the frame)
    \str_set:Nx \pack@l@lastPath_str {\curfile}
    \pack@input@popFrame:
}
\cs_generate_variant:Nn \pack@doInsert:Nn {Nx, NV}


% >>
% -----------------| input.realisation.end
% -----------------| input.internal.begin
% >>

\tl_new:N   \pack@l@void_tl  % dummy variable
\tl_new:N   \pack@l@temp_tl  % variable to be used in-place
\tl_new:N   \pack@l@temp_a_tl  % variable to be used in-place
\tl_new:N   \pack@l@temp_b_tl  % variable to be used in-place
\str_new:N  \pack@l@temp_str % variable to be used in-place
\str_new:N  \pack@l@lastPath_str
\seq_new:N  \pack@l@temp_seq % variable to be used in-place
\seq_new:N  \pack@l@pathSequence_seq
\seq_new:N  \pack@l@rootSequence_seq
\bool_new:N \pack@l@bRelPath


%%% create a new include frame and actualize current path's variables
%   #1    - path to a destination file
\cs_new_protected:Npn \pack@input@putFrame:n #1 { \group_begin:
    % split a passed path onto a list of directory/file names
    \seq_set_split:Nnn \pack@l@pathSequence_seq {/}{#1}
    
    % check if the path is relative
    \seq_get_left:NN \pack@l@pathSequence_seq \pack@l@temp_tl
    \tl_if_eq:NnTF \pack@l@temp_tl {.} 
    {   % the path is file-relative. 
        % It's necessary to prepend a current file's directory to the path
        \seq_put_left:Nx \pack@l@pathSequence_seq {\curdir}
        \bool_set_true:N \pack@l@bRelPath
    }
    {   % the path is document-relative. 
        % Use the path as is
        \bool_set_false:N \pack@l@bRelPath
    }

    % sanitize path
    \pack@input@sanitizePathSeq:N \pack@l@pathSequence_seq
    
    % get a base directory
    \seq_set_eq:NN    \pack@l@rootSequence_seq \pack@l@pathSequence_seq
    \seq_pop_right:NN \pack@l@rootSequence_seq \pack@l@void_tl

    % convert the paths to tls and push them to a new frame
    \seq_gput_right:Nx \pack@g@rootStack_seq {\seq_use:Nnnn \pack@l@rootSequence_seq {/}{/}{/}}
    \seq_gput_right:Nx \pack@g@fileStack_seq {\seq_use:Nnnn \pack@l@pathSequence_seq {/}{/}{/}}
    \seq_gput_right:NV \pack@g@bRelStack_seq \pack@l@bRelPath
    \pack@input@syncVariables:
    \group_end:
}


%%% pop current frame's variables
\cs_new_protected:Npn \pack@input@popFrame: {
    \seq_gpop_right:NN \pack@g@rootStack_seq \pack@l@void_tl
    \seq_gpop_right:NN \pack@g@fileStack_seq \pack@l@void_tl
    \seq_gpop_right:NN \pack@g@bRelStack_seq \pack@l@void_tl
    \pack@input@syncVariables:
}


%%% place top elements from stacks to destination variables
\cs_new_protected:Npn \pack@input@syncVariables: {
    \pack@input@syncVariables@str:NN  \pack@g@rootStack_seq \pack@g@fullRoot_str
    \pack@input@syncVariables@str:NN  \pack@g@fileStack_seq \pack@g@fullPath_str
    \pack@input@syncVariables@bool:NN \pack@g@bRelStack_seq \pack@g@bRelPath
}


%%% place a top element from the stack to the destination variable
%   #1  - a stack (sequence) to get a top element from
%   #2  - the top elemen't destination global variable
\cs_new_protected:Npn \pack@input@syncVariables@str:NN #1 #2 { \group_begin:
    \seq_get_right:NN #1  \pack@l@temp_tl
    \str_gset:Nx      #2 {\pack@l@temp_tl}
    \group_end:
}
\cs_new_protected:Npn \pack@input@syncVariables@bool:NN #1 #2 { \group_begin:
    \seq_get_right:NN #1  \pack@l@temp_tl
    \bool_gset:Nn     #2 {\pack@l@temp_tl}
    \group_end:
}


%%% remove garbage path names
%   #1  - name of sequence variable with directory/file names
\cs_new_protected:Npn \pack@input@sanitizePathSeq:N #1 {
    \seq_remove_all:Nn #1 {}  % remove same dirs
    \seq_remove_all:Nn #1 {.} % remove same dirs
}


\cs_new_protected:Npn \pack@input@addEvent:Nnn #1 #2 #3
{
    \pack@msg@eventNew:nnn{>>}{#2}{#3}
    \seq_gput_right:Nn #1 {#2<<>>#3}
}


%%% call all events from an event-list that match a passed path
%   #1  - event list
%   #2  - file path
\cs_new_protected:Npn \pack@input@callEvent:Nn #1 #2
{
    \seq_map_inline:Nn #1
    {
        \regex_split:nnNTF {<<>>} {##1} \pack@l@temp_seq
        {
            \seq_pop_left:NN \pack@l@temp_seq \pack@l@temp_a_tl
            \seq_pop_left:NN \pack@l@temp_seq \pack@l@temp_b_tl
            \pack@input@callEvent@internal:VVn \pack@l@temp_a_tl \pack@l@temp_b_tl {#2}
        } {
            \PackageError{Error: ~ Unexpected ~ item: ~ ##1}
            \stop
        }
    }
}
%%% check that a passed path matches a passed pattern and call an associated callback
%   #1  - regex pattern
%   #2  - callback
%   #3  - file path 
\cs_new_protected:Npn \pack@input@callEvent@internal:nnn #1 #2 #3
{
    \regex_match:nnT {#1}{#3}
    {
        \pack@msg@eventCall:nnn{#1}{#3}{#2}
        #2
    }
}
\cs_generate_variant:Nn \pack@input@callEvent:Nn {Nx, NV}
\cs_generate_variant:Nn \pack@input@callEvent@internal:nnn {VVn}


% >>
% -----------------| input.internal.end


\typeout{*********************************************************************}

% LaTeX3 support >> off
\makeatother
\ExplSyntaxOff
